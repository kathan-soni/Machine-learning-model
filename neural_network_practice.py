# -*- coding: utf-8 -*-
"""neural_network_practice.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/15QH3qXGdInMOnqf6arI2ABtUw4Qg8Hd7
"""

import tensorflow as tf
from tensorflow import keras
import numpy as np
import matplotlib.pyplot as plt
from tensorflow.keras.utils import plot_model

"""we will use MNIST fashion dataset
here dataset has 60,000 images for training and 10,000 images for testing
"""

fashion_mnist = keras.datasets.fashion_mnist # loads the dataset
(train_images, train_labels), (test_images, test_labels) = fashion_mnist.load_data()
# split into training and testing

train_images.shape
# we have 28 pixels 28 rows and total 60,000 images with 28X28 = 784 pixels
type(train_images)

train_images[0, 23, 23]# to look at one pixel
# image 0 means 1st image of row 23 , column 23
# simply represented by number between 0 and 255
# and this show the gray scale value of this pixel

train_labels[:10] # shows first 10 training labels

class_names = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat',
               'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']

plt.figure() # make figure
plt.imshow(train_images[6]) # choose image
plt.colorbar() # choose color
plt.grid(False) # no grid require
plt.show() # show the image
# prints seccond image and show the figure with color and with no grids

train_images = train_images / 255.0 # putting in range 0 and 1 as we know now since
# we know we have pixels value in 255 so we gonna divide it with 255 and it will scale us

test_images = test_images / 255.0 # do same with test images both data should be in same form

"""lets Build the model"""

pip install pydot

model = keras.Sequential([
    keras.layers.Flatten(input_shape = (28, 28)), # input layer (1)
    # it will have 784 neurons, we use flatten layer to denote that our input
    # should come in this shape, flatten will reshape the (28,28) array into
    # vector of 784 neurons so that each pixel associates with each neuron
    keras.layers.Dense(128, activation='relu'), # hidden layer (2)
    # this is hidden layer and dense means it will be fully connected and each
    # neuron from the previous layer will connects to each neuron of this layer
    # it has 128 neurons and uses rectify linear unit activation function

    keras.layers.Dense(10, activation='softmax') # output layer
    # softmax is used to calculate the probability distribution for each class
    # and there are 10 different class for each neuron's probability
    # softmax means value of any neuron in this layer will be between 0 and 1
    # where 1 = high probability of image being in that class
])

"""Compiling the model"""

model.compile(optimizer='adam',
              loss = 'sparse_categorical_crossentropy',
              metrics=['accuracy'])

model.fit(train_images, train_labels, epochs = 10)

"""train the model

"""

model.fit(train_images, train_labels, epochs = 1)
# accuracy which came is on testing or training the data
# lets change epochs to see if it can make it better and change value from 10
# to 8
# now try with epoch = 1

"""To find true accuracy lets Evaluate the model"""

test_loss, test_acc = model.evaluate(test_images, test_labels, verbose = 1)
print('Test accuracy :', test_acc)
# we changed epochs but it doesnt make difference in accuracy

"""above it was showing 93 accuracy but now it is showing 88 because we passed new data so overfitting occured.
it means our model was doing great on training data but no with new data

Lets make the Predictions
"""

predictions = model.predict(test_images)
print(class_names[np.argmax(predictions[1])]) # every single image has list which represent prediction for it
# now we tested for 0 index image
# it will give probabiity distribution calculated on output layer for 0th image
# now for predicting class we are using we use np.argmax which will return
# index of maximum value in the list
# now to know class to check which class is of it and lets see the image by plotting
plt.figure()
plt.imshow(test_images[2])
plt.colorbar()
plt.grid(False)
plt.show()
# we will see image of ankle boot
# lets do for another image change predicton from 0 to 1
# now we see pullover image

test_images.shape

"""Now make predictions on any image we want by creating function get_number, we we will write number it will find that image in dataset , it will prediction on that from model and then will show what actually is versus what is predicted being"""

COLOR = 'white'
plt.rcParams['text.color'] = COLOR
plt.rcParams['axes.labelcolor'] = COLOR

def predict(model, image, correct_label):
  class_names = ['T-shirt/top', 'Trouser', 'Pullover', 'Dress', 'Coat',
               'Sandal', 'Shirt', 'Sneaker', 'Bag', 'Ankle boot']
  predictions = model.predict(np.array([image]))
  predicted_class = class_names[np.argmax(predictions)]
  show_image(image, class_names[correct_label], predicted_class)

def show_image(img, label, guess):
  plt.figure()
  plt.imshow(img, cmap=plt.cm.binary)
  plt.title("Excepted " + label)
  plt.xlabel("Guess " + guess)
  plt.colorbar()
  plt.grid(False)
  plt.show()

def get_number():
  while True:
    num = input("pick a number : ")
    if num.isdigit():
      num = int(num)
      if 0 <= num <= 1000:
        return int(num)
    else:
      print("try again..")
num = get_number()
image = test_images[num]
label = test_labels[num]
predict(model, image, label)

#

